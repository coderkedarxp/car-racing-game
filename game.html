<!DOCTYPE html>
<html>
<head>
    <title>Racing Game - Multiplayer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #333;
            height: 100vh;
            overflow: hidden;
        }
        #usernameDisplay {
            color: white;
            font-size: 20px;
            margin: 10px;
        }
        #gameCanvas {
            border: 1px solid black;
            background: #555;
            width: 600px;
            height: calc(100% - 40px);
        }
        #gameOverScreen1, #gameOverScreen2 {
            display: none;
            position: absolute;
            top: 50%;
            width: 200px;
            text-align: center;
            color: white;
            font-size: 30px;
            font-family: Arial, sans-serif;
            z-index: 10;
        }
        #gameOverScreen1 { left: 150px; transform: translate(-50%, -50%); }
        #gameOverScreen2 { left: 450px; transform: translate(-50%, -50%); }
        #replayButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        #replayButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="usernameDisplay"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOverScreen1"><div>Game Over</div><button id="replayButton1">Replay</button></div>
    <div id="gameOverScreen2"><div>Game Over</div><button id="replayButton2">Replay</button></div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const roadWidth = 200;
        const road1X = 50;
        const road2X = 350;
        const carWidth = 40, carHeight = 60;
        const obstacleWidth = 80, obstacleHeight = 100;
        const laneLeftOffset = roadWidth / 4;
        const laneRightOffset = 3 * roadWidth / 4;

        let player1 = { x: road1X + laneLeftOffset, angle: 0, targetAngle: 0, lane: 'left', gameOver: false, score: 0 };
        let player2 = { x: road2X + laneLeftOffset, angle: 0, targetAngle: 0, lane: 'left', gameOver: false, score: 0 };
        let obstacles = [];
        let roadsideObjects1 = [], roadsideObjects2 = [];
        let gameTime = 0, baseSpeed = 3, speed = baseSpeed, minGap = 250, lastObstacleY = -minGap, dashOffset = 0;
        const spacing = 200;

        const playerCarImg = new Image(); playerCarImg.src = 'images/playerCar.png';
        const obstacleCars = [
            new Image(), new Image(), new Image(), new Image(), new Image(), new Image(), new Image()
        ];
        obstacleCars[0].src = 'images/Ambulance.png';
        obstacleCars[1].src = 'images/Audi.png';
        obstacleCars[2].src = 'images/Black_viper.png';
        obstacleCars[3].src = 'images/Police.png';
        obstacleCars[4].src = 'images/taxi.png';
        obstacleCars[5].src = 'images/truck.png';
        obstacleCars[6].src = 'images/Mini_truck.png';
        const obstacleImageMap = {
            'Ambulance.png': obstacleCars[0],
            'Audi.png': obstacleCars[1],
            'Black_viper.png': obstacleCars[2],
            'Police.png': obstacleCars[3],
            'taxi.png': obstacleCars[4],
            'truck.png': obstacleCars[5],
            'Mini_truck.png': obstacleCars[6]
        };
        const lightPoleLeftImg = new Image(); lightPoleLeftImg.src = 'images/lightPoleLeft.png';
        const lightPoleRightImg = new Image(); lightPoleRightImg.src = 'images/lightPoleRight.png';
        const treeImg = new Image(); treeImg.src = 'images/tree.png';

        const socket = new WebSocket('ws://localhost:8765');
        let playerId = null;
        let gameStarted = false;

        socket.onopen = () => {
            console.log("WebSocket connected");
            socket.send(JSON.stringify({ type: 'join', username: localStorage.getItem('username') || 'Unknown' }));
        };
        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("Received:", data);
            if (data.type === 'init') {
                playerId = data.playerId;
                document.getElementById('usernameDisplay').textContent = `Player ${playerId}: ${localStorage.getItem('username')}`;
            } else if (data.type === 'start') {
                gameStarted = true;
                startGame();
            } else if (data.type === 'state') {
                player1.x = data.players[0].x;
                player1.gameOver = data.players[0].gameOver;
                player1.score = data.players[0].score;
                player2.x = data.players[1].x;
                player2.gameOver = data.players[1].gameOver;
                player2.score = data.players[1].score;
                obstacles = data.obstacles;
                speed = data.speed;
                gameTime = data.gameTime;
                dashOffset = data.dashOffset;
            }
        };
        socket.onerror = (error) => console.error("WebSocket error:", error);
        socket.onclose = () => console.log("WebSocket closed");

        let imagesLoaded = 0, totalImages = 10;
        function imageLoaded() { 
            imagesLoaded++; 
            console.log(`Images loaded: ${imagesLoaded}/${totalImages}`); 
            if (imagesLoaded === totalImages) console.log("Images ready, waiting for server to start game");
        }
        function imageError(img) { console.error(`Failed to load: ${img.src}`); }
        playerCarImg.onload = imageLoaded; playerCarImg.onerror = () => imageError(playerCarImg);
        obstacleCars.forEach(img => { img.onload = imageLoaded; img.onerror = () => imageError(img); });
        lightPoleLeftImg.onload = imageLoaded; lightPoleLeftImg.onerror = () => imageError(lightPoleLeftImg);
        lightPoleRightImg.onload = imageLoaded; lightPoleRightImg.onerror = () => imageError(lightPoleRightImg);
        treeImg.onload = imageLoaded; treeImg.onerror = () => imageError(treeImg);

        canvas.width = 600;
        canvas.height = window.innerHeight - 40;

        function drawRoad(x, gameOver) {
            ctx.fillStyle = 'gray';
            ctx.fillRect(x, 0, roadWidth, canvas.height);
            ctx.beginPath();
            ctx.setLineDash([20, 10]);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.lineDashOffset = gameOver ? 0 : dashOffset;
            ctx.moveTo(x + 50, 0);
            ctx.lineTo(x + 50, canvas.height);
            ctx.moveTo(x + roadWidth - 50, 0);
            ctx.lineTo(x + roadWidth - 50, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.setLineDash([50, 20]);
            ctx.lineWidth = 4;
            ctx.moveTo(x + roadWidth / 2, 0);
            ctx.lineTo(x + roadWidth / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawCar(player) {
            ctx.save();
            ctx.translate(player.x, canvas.height - carHeight / 2 - 10);
            ctx.rotate(player.angle);
            ctx.drawImage(playerCarImg, -carWidth / 2, -carHeight / 2, carWidth, carHeight);
            ctx.restore();
        }

        function initRoadsideObjects(roadX, objects) {
            for (let y = -spacing; y <= canvas.height + spacing; y += spacing * 2) {
                objects.push({ x: roadX - 30, y, img: treeImg, side: 'left', type: 'tree' });
                objects.push({ x: roadX - 30, y: y + spacing, img: lightPoleLeftImg, side: 'left', type: 'pole' });
                objects.push({ x: roadX + roadWidth + 10, y, img: treeImg, side: 'right', type: 'tree' });
                objects.push({ x: roadX + roadWidth + 10, y: y + spacing, img: lightPoleRightImg, side: 'right', type: 'pole' });
            }
        }

        function updateRoadsideObjects(objects, gameOver) {
            if (!gameOver) {
                objects.forEach(o => { o.y += speed; });
                objects.forEach(o => { if (o.y > canvas.height + 50) o.y -= (canvas.height + spacing * 2); });
            }
        }

        function drawRoadsideObjects(objects) {
            objects.forEach(o => ctx.drawImage(o.img, o.x, o.y, 20, 50));
        }

        document.addEventListener('keydown', (e) => {
            if (playerId) {
                let player = playerId === 1 ? player1 : player2;
                let roadX = playerId === 1 ? road1X : road2X;
                if (!player.gameOver) {
                    if (e.key === 'ArrowLeft' && player.lane !== 'left') {
                        player.targetX = roadX + laneLeftOffset;
                        player.targetAngle = -0.26;
                        player.lane = 'left';
                        socket.send(JSON.stringify({ type: 'move', playerId, x: player.targetX }));
                    } else if (e.key === 'ArrowRight' && player.lane !== 'right') {
                        player.targetX = roadX + laneRightOffset;
                        player.targetAngle = 0.26;
                        player.lane = 'right';
                        socket.send(JSON.stringify({ type: 'move', playerId, x: player.targetX }));
                    }
                }
            }
        });

        function startGame() {
            console.log("Starting game");
            initRoadsideObjects(road1X, roadsideObjects1);
            initRoadsideObjects(road2X, roadsideObjects2);
            gameLoop();
        }

        function gameLoop() {
            try {
                if (!gameStarted) return;
                console.log("Game loop running, frame:", gameTime);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawRoad(road1X, player1.gameOver);
                drawRoad(road2X, player2.gameOver);
                updateRoadsideObjects(roadsideObjects1, player1.gameOver);
                updateRoadsideObjects(roadsideObjects2, player2.gameOver);
                drawRoadsideObjects(roadsideObjects1);
                drawRoadsideObjects(roadsideObjects2);

                const moveSpeed = 0.2;
                [player1, player2].forEach(player => {
                    player.angle += (player.targetAngle - player.angle) * moveSpeed;
                    if (Math.abs(player.targetAngle - player.angle) < 0.01) {
                        player.angle = player.targetAngle;
                        if (player.x === player.targetX) player.targetAngle = 0;
                    }
                    if (!player.gameOver) drawCar(player);
                });

                obstacles.forEach(o => {
                    console.log("Drawing obstacle:", o);
                    const img = obstacleImageMap[o.img];
                    if (img) {
                        if (!player1.gameOver) ctx.drawImage(img, o.x - obstacleWidth / 2, o.y, obstacleWidth, obstacleHeight);
                        if (!player2.gameOver && o.side === 'left') {
                            ctx.drawImage(img, o.x - obstacleWidth / 2 + 300, o.y, obstacleWidth, obstacleHeight);
                        }
                    } else {
                        console.warn(`Image not found for ${o.img}`);
                    }
                });

                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`Score: ${Math.floor(player1.score)}`, road1X, 20);
                ctx.fillText(`Score: ${Math.floor(player2.score)}`, road2X, 20);

                if (player1.gameOver) document.getElementById('gameOverScreen1').style.display = 'block';
                if (player2.gameOver) document.getElementById('gameOverScreen2').style.display = 'block';

                if (!player1.gameOver || !player2.gameOver) dashOffset -= speed;
                if (dashOffset <= -70) dashOffset += 70;

                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("Game loop error:", e);
            }
        }

        document.getElementById('replayButton1').addEventListener('click', () => socket.send(JSON.stringify({ type: 'reset', playerId: 1 })));
        document.getElementById('replayButton2').addEventListener('click', () => socket.send(JSON.stringify({ type: 'reset', playerId: 2 })));
    </script>
</body>
</html>